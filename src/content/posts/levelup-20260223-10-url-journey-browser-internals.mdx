---
ticketId: "Lv-10"
title: "一個 URL 的旅程 — 從你按 Enter 到畫面出現，瀏覽器到底在幹嘛"
originalDate: "2026-02-23"
source: "Level-Up 系列"
sourceUrl: "https://gu-log.vercel.app/posts/levelup-20260223-10-url-journey-browser-internals"
summary: "你每天打網址、按 Enter，但中間到底發生了什麼事？這篇用 gu-log 當案例，從 DNS 到 Service Worker，7 個 Floor 帶你走完一個 URL 的完整旅程。"
lang: "zh-tw"
tags: ["browser", "dns", "tcp", "tls", "http", "rendering", "service-worker", "cache", "tutorial", "level-up"]
---

import LevelUpProgress from '../../components/LevelUpProgress.astro';
import LevelUpQuiz from '../../components/LevelUpQuiz.astro';
import ClawdNote from '../../components/ClawdNote.astro';
import AnalogyBox from '../../components/AnalogyBox.astro';

歡迎來到 Level-Up 系列第十篇。

這次不講 OpenClaw，講一件你每天做一百次但從來沒想過的事：

**你在 Safari 打了 `gu-log.vercel.app`，按下 Enter。**

然後畫面就出現了。

但中間到底發生了什麼？從你手指離開鍵盤到文章出現在螢幕上，大概經歷了 7 個階段、跨越了半個地球的基礎建設。這篇要把這條路走一遍。

全程用 gu-log 當案例。你看完這篇，以後每次開網頁都會忍不住想：「啊，現在在 TLS handshake。」

---

## 🏰 Floor 0：全景圖 — 一個 Request 的生命週期

<LevelUpProgress current={0} total={7} title="一個 URL 的旅程" />

先看完整流程，之後每個 Floor 拆開講：

```
你按 Enter
    ↓
1. DNS Lookup     → 「gu-log.vercel.app 的 IP 是什麼？」
    ↓
2. TCP Handshake  → 「嗨，你在嗎？」「在。」「好，開始。」
    ↓
3. TLS Handshake  → 「我們用密語講，旁人聽不懂。」
    ↓
4. HTTP Request   → 「給我 /index.html」
    ↓
5. HTTP Response  → 「拿去，200 OK，附 HTML」
    ↓
6. Rendering      → 瀏覽器把 HTML 變成你看到的畫面
    ↓
7. Cache / SW     → 「下次來我直接從口袋掏給你」
```

<AnalogyBox title="Python 類比">
想像你寫了一個 FastAPI server。有人用 `requests.get("https://gu-log.vercel.app")` 打你的 API。

上面這 7 步，就是 `requests.get()` 背後真正在做的事。你平常一行 code 搞定，但底層跑了這麼多東西。
</AnalogyBox>

整個流程在好的網路環境下大概 **200-500ms**。是的，不到半秒。

<LevelUpQuiz
  question="上面 7 步裡，哪一步是「把 domain name 翻譯成 IP address」？"
  options={[
    { label: "A", text: "TCP Handshake" },
    { label: "B", text: "DNS Lookup" },
    { label: "C", text: "TLS Handshake" },
    { label: "D", text: "我他媽完全不知道 🤷" },
  ]}
  answer="B"
  explanation="DNS = Domain Name System，就是網路世界的電話簿。瀏覽器不認得 gu-log.vercel.app，只認 76.76.21.21 這種 IP。"
/>

---

## 🏰 Floor 1：DNS — 網路世界的電話簿

<LevelUpProgress current={1} total={7} title="一個 URL 的旅程" />

你打了 `gu-log.vercel.app`。瀏覽器第一件事：

「這個名字的 IP 是什麼？」

<AnalogyBox title="比喻：打電話">
你想打給阿嬤，但你不記得她的電話號碼。所以你：

1. 先翻自己的通訊錄（**瀏覽器 DNS cache**）
2. 沒有 → 問 Siri（**作業系統 DNS cache**）
3. 還是沒有 → 打 104 查號台（**DNS Resolver**，通常是 ISP 或 Google 8.8.8.8）
4. 查號台也不知道 → 它一層一層問上去（Root → .app → vercel.app → gu-log.vercel.app）

最後拿到號碼：`76.76.21.21`。
</AnalogyBox>

用 pseudocode 表示：

```python
# DNS 查詢流程（簡化版）
def dns_lookup(domain: str) -> str:
    # 1. 查本地 cache
    if domain in browser_dns_cache:
        return browser_dns_cache[domain]

    if domain in os_dns_cache:
        return os_dns_cache[domain]

    # 2. 問 DNS Resolver（遞迴查詢）
    ip = dns_resolver.query(domain)
    # resolver 內部：root → .app → vercel.app → gu-log.vercel.app

    # 3. 存進 cache，下次就不用再問
    browser_dns_cache[domain] = ip  # TTL 通常 5min ~ 1hr
    return ip

ip = dns_lookup("gu-log.vercel.app")
# → "76.76.21.21"
```

<ClawdNote variant="murmur">
DNS 是 1983 年發明的。四十多年了，整個網際網路還是靠這套「先查電話簿」的機制在運作。很土但很穩。
</ClawdNote>

**DNS 可能出問題的地方：**

- DNS cache 過期（TTL 到了）→ 要重新查，多花 20-100ms
- DNS server 掛了 → 網站打不開但其實 server 沒壞
- DNS 被污染（某些地區）→ 查到錯誤的 IP

<LevelUpQuiz
  question="為什麼瀏覽器要有 DNS cache？"
  options={[
    { label: "A", text: "因為 DNS 查詢要跨網路、花時間，cache 可以省掉這段" },
    { label: "B", text: "因為 DNS server 不安全，cache 比較安全" },
    { label: "C", text: "因為瀏覽器一定要有 cache 才能運作" },
    { label: "D", text: "我他媽完全不知道 🤷" },
  ]}
  answer="A"
  explanation="每次 DNS 查詢要跟 resolver 來回溝通，快的話 10ms，慢的話 100ms+。同一個網站一天可能開很多次，cache 住就不用每次都問。跟你在 FastAPI 用 @lru_cache 一樣的道理。"
/>

---

## 🏰 Floor 2：TCP + TLS — 握手與密語

<LevelUpProgress current={2} total={7} title="一個 URL 的旅程" />

拿到 IP 了。接下來要「建立連線」。

這分成兩步：TCP 握手（確認對方在）→ TLS 握手（加密通道）。

**TCP Three-Way Handshake（三次握手）：**

```
你的瀏覽器          Vercel Server
    |                    |
    |--- SYN ----------->|    「嗨，你在嗎？」
    |                    |
    |<-- SYN-ACK --------|    「在，你也在嗎？」
    |                    |
    |--- ACK ----------->|    「在。好，我們開始。」
    |                    |
    |   ✅ TCP 連線建立    |
```

<AnalogyBox title="Python 類比">
TCP 就像你寫 FastAPI 的時候，uvicorn 先 `bind()` 一個 port，然後 `listen()`，等 client `connect()`。三次握手就是 client 跟 server 確認「我找得到你、你也找得到我」。

```python
# 簡化版 — 實際由 OS kernel 處理
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("76.76.21.21", 443))  # 三次握手在這裡發生
```
</AnalogyBox>

**TLS Handshake（加密握手）：**

TCP 連好了，但目前是明文。因為 gu-log 用 HTTPS（那個 S = Secure），需要 TLS 加密：

```
你的瀏覽器          Vercel Server
    |                    |
    |--- ClientHello --->|   「我支援這些加密方式」
    |                    |
    |<-- ServerHello ----|   「好，我們用 TLS 1.3 + AES-256」
    |<-- 憑證 + 公鑰 -----|   「這是我的身份證（SSL 證書）」
    |                    |
    |   [驗證證書 ✅]       |
    |--- 金鑰交換 -------->|   「用這個 shared secret 加密」
    |                    |
    |   ✅ 加密通道建立     |
```

<ClawdNote variant="warn">
面試常見問題：「HTTPS 跟 HTTP 差在哪？」答案不是「比較安全」（太廢話）。正確答案：HTTP 是明文傳輸，HTTPS 在 TCP 之上多了一層 TLS 加密，防竊聽、防篡改、驗身份。
</ClawdNote>

**時間成本：**
- TCP 握手：1 個 RTT（round-trip time），大約 10-50ms
- TLS 1.3 握手：1 個 RTT（TLS 1.2 要 2 個）
- 加起來大概 20-100ms，看你跟 server 的距離

<LevelUpQuiz
  question="為什麼 TCP 要三次握手，兩次不行嗎？"
  options={[
    { label: "A", text: "兩次就夠了，三次是歷史包袱" },
    { label: "B", text: "三次才能確認『雙方都能收到對方的訊息』" },
    { label: "C", text: "因為 RFC 規定的，沒有技術原因" },
    { label: "D", text: "我他媽完全不知道 🤷" },
  ]}
  answer="B"
  explanation="兩次只能確認 server 能收到 client 的訊息。第三次（client → server 的 ACK）才能讓 server 確認 client 也能收到它的回覆。就像打電話：你說「喂」→ 對方說「喂」→ 你說「聽到了」。少了最後一步，對方不知道你有沒有聽到。"
/>

---

## 🏰 Floor 3：HTTP — 點餐與出餐

<LevelUpProgress current={3} total={7} title="一個 URL 的旅程" />

加密通道建好了，終於可以講正事了。

瀏覽器送出 HTTP Request：

```http
GET / HTTP/2
Host: gu-log.vercel.app
Accept: text/html
User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 26_0 ...)
Accept-Language: zh-TW,zh;q=0.9,en;q=0.8
```

Vercel 的 server 回：

```http
HTTP/2 200 OK
Content-Type: text/html; charset=utf-8
Cache-Control: public, max-age=0, must-revalidate
Content-Length: 48726

<!DOCTYPE html><html lang="zh-TW">...
```

<AnalogyBox title="比喻：點餐">
- **Request** = 你在 Uber Eats 下單：「我要一份 index.html，送到我的瀏覽器」
- **Response** = 餐廳回你：「好的，200 OK，菜來了」
- **Status Code** = 出餐狀態
  - `200` = 菜來了 ✅
  - `301` = 這家搬了，去新地址（redirect）
  - `404` = 我們沒有這道菜
  - `500` = 廚房爆炸了
  - `429` = 你點太多了，等一下（rate limit）
</AnalogyBox>

```python
# FastAPI 對照：你每天在寫的就是 Response 那一端
from fastapi import FastAPI
app = FastAPI()

@app.get("/")
async def homepage():
    return HTMLResponse(content="<html>...", status_code=200)
    # ↑ 這就是瀏覽器收到的那個 HTTP Response
```

**重要 Headers 你該知道的：**

- `Cache-Control` — 告訴瀏覽器「這個 response 要不要存、存多久」
- `Content-Type` — 這包裹裡是 HTML？JSON？圖片？
- `Set-Cookie` — server 塞 cookie 給你（登入狀態之類的）
- `ETag` — 內容的指紋，下次來可以問「這個有沒有變？」（省流量）

<ClawdNote variant="murmur">
你用 FastAPI 開發時，`uvicorn` 幫你處理了 TCP/TLS/HTTP parsing 的所有髒活。你只要寫 `return {"hello": "world"}`，底層幫你包成 HTTP Response。這就是為什麼框架存在：不是因為你做不到，是因為你不想每次都做。
</ClawdNote>

<LevelUpQuiz
  question="HTTP Status Code 429 代表什麼？"
  options={[
    { label: "A", text: "Server 內部錯誤" },
    { label: "B", text: "你送太多 request 了，被 rate limit" },
    { label: "C", text: "找不到頁面" },
    { label: "D", text: "我他媽完全不知道 🤷" },
  ]}
  answer="B"
  explanation="429 Too Many Requests。你的 FastAPI 如果加了 rate limiter（像 slowapi），超過限制就會回 429。OpenClaw 的 Telegram bot 在 restart storm 時就是被 Telegram API 打回 429，retry-after 一路飆到 1913 秒。"
/>

---

## 🏰 Floor 4：Rendering — 把 HTML 變成畫面

<LevelUpProgress current={4} total={7} title="一個 URL 的旅程" />

瀏覽器收到 HTML 了。接下來是最複雜的一步：**把一堆文字變成你螢幕上看到的漂亮畫面。**

這個過程叫 **Rendering Pipeline**，分成幾個階段：

```
HTML 字串
    ↓ parse
DOM Tree（文件結構）
    ↓
CSS 字串
    ↓ parse
CSSOM（樣式結構）
    ↓
DOM + CSSOM 合體
    ↓
Render Tree（要顯示的東西 + 長什麼樣）
    ↓
Layout（每個元素放哪裡、多大）
    ↓
Paint（畫出 pixels）
    ↓
Composite（把不同圖層合成最終畫面）
    ↓
你看到 gu-log 首頁 ✨
```

<AnalogyBox title="比喻：蓋房子">
- **DOM** = 設計圖（幾個房間、什麼結構）
- **CSSOM** = 裝潢方案（牆壁什麼色、地板什麼材質）
- **Render Tree** = 設計圖 + 裝潢合體 → 「這間房間在這裡，漆藍色」
- **Layout** = 量尺寸、釘位置
- **Paint** = 真的開始刷油漆
- **Composite** = 把每面牆、每層樓合成完整的房子
</AnalogyBox>

```python
# Pseudocode：Rendering Pipeline
def render_page(html: str, css: str) -> Pixels:
    # 1. Parse HTML → DOM Tree
    dom = parse_html(html)
    # 像 BeautifulSoup(html, 'html.parser') 但瀏覽器版本

    # 2. Parse CSS → CSSOM
    cssom = parse_css(css)

    # 3. 合體
    render_tree = merge(dom, cssom)
    # 只包含「可見」的元素（display:none 的不算）

    # 4. Layout — 算位置跟大小
    layout = calculate_layout(render_tree)
    # 每個元素的 x, y, width, height

    # 5. Paint — 畫出來
    layers = paint(layout)

    # 6. Composite — 合成
    return composite(layers)
```

**中間如果遇到 `<script>` 會怎樣？**

瀏覽器遇到 JS 會**停下 rendering 去執行**（因為 JS 可能改 DOM）。這就是為什麼：
- `<script>` 建議放 `</body>` 前面或加 `defer`
- 不然使用者會看到白畫面等 JS 跑完

<ClawdNote variant="murmur">
gu-log 的 theme toggle script 放在 `<head>` 裡但用了 inline script，這樣才能在 render 前就設好 dark/light mode，不會閃白畫面。這是故意擋住 rendering 的少數正當理由之一。
</ClawdNote>

<LevelUpQuiz
  question="瀏覽器在 rendering 時，如果遇到一個沒有 defer 的 <script> 標籤，會怎麼做？"
  options={[
    { label: "A", text: "忽略它，繼續 render" },
    { label: "B", text: "停下 rendering，先執行 JS，再繼續" },
    { label: "C", text: "在背景同時執行 JS 和 render" },
    { label: "D", text: "我他媽完全不知道 🤷" },
  ]}
  answer="B"
  explanation="這叫 render-blocking。瀏覽器怕 JS 會改 DOM（像 document.write），所以必須先跑完 JS 才能繼續 parse HTML。這就是為什麼 script 放在底部或加 defer/async 是 best practice。"
/>

---

## 🏰 Floor 5：Cache 家族 — 三兄弟各司其職

<LevelUpProgress current={5} total={7} title="一個 URL 的旅程" />

頁面顯示了。但如果你 5 秒後再打一次 gu-log，瀏覽器不會傻傻重走上面整條路。因為有 **cache**。

Cache 不是一個東西，而是一個家族。介紹三兄弟：

**大哥：Browser HTTP Cache（瀏覽器自動管理）**

```python
# Server 回 response 時帶了這個 header：
# Cache-Control: public, max-age=31536000

# 瀏覽器心想：
if response.headers["Cache-Control"].max_age > 0:
    browser_cache.store(url, response)
    # 下次同一個 URL，直接從 cache 拿，不問 server
```

- 你沒辦法控制存什麼（server 的 `Cache-Control` header 決定）
- CSS、JS、圖片通常會被 cache
- HTML 通常 `max-age=0`（每次都問 server 有沒有更新）

**二哥：CDN Cache（Vercel Edge Network）**

```
你 (台北) → Vercel Edge (東京) → Vercel Origin (美東)
              ↑
          CDN 在這裡 cache
```

- CDN 把內容存在離你最近的 edge server
- 你在台北打 gu-log，拿到的是東京 edge 的 cache，不用跑到美國
- 你依然需要網路才能連 CDN（離線時 CDN 幫不了你）

**三弟：Cache API（開發者完全控制）**

```python
# 這就是 Service Worker 用的 cache
# 開發者自己決定存什麼、存多久、怎麼更新

cache = await caches.open("pages-cache")
response = await fetch("/posts/some-article")
await cache.put("/posts/some-article", response)

# 完全你的地盤，瀏覽器不會亂動它
```

- 離線也能用 ✅（這就是 PWA 的核心）
- 你決定 cache 什麼、什麼時候清除
- 需要寫 code（通常透過 Service Worker）

<ClawdNote variant="murmur">
大哥是自動管家（server 說了算），二哥是外包快遞（CDN 幫你就近送貨），三弟是你的私人保險箱（你自己管）。gu-log 的離線功能靠的就是三弟。
</ClawdNote>

<LevelUpQuiz
  question="你關掉 WiFi 後還能看 gu-log 文章，是哪個 cache 在幫你？"
  options={[
    { label: "A", text: "CDN Cache — Vercel 的 edge server 離我很近" },
    { label: "B", text: "Browser HTTP Cache — 瀏覽器之前存過" },
    { label: "C", text: "Cache API — Service Worker 把頁面存進去了" },
    { label: "D", text: "我他媽完全不知道 🤷" },
  ]}
  answer="C"
  explanation="CDN 要有網路才能連（排除）。Browser HTTP Cache 理論上也能離線用，但它的行為不可控（可能被清掉）。PWA 離線功能靠的是 Cache API + Service Worker，開發者完全控制。這就是我們在 gu-log 做的事。"
/>

---

## 🏰 Floor 6：Service Worker — 你跟 Server 之間的中間人

<LevelUpProgress current={6} total={7} title="一個 URL 的旅程" />

最後一關。也是我們剛在 gu-log 實作的東西。

**Service Worker 是什麼？**

一個跑在瀏覽器背景的 JavaScript 程式（`sw.js`），專門攔截你的網路 request。

```
你打 gu-log.vercel.app
    ↓
瀏覽器：「我要 fetch 這個 URL」
    ↓
Service Worker 攔截：「等等，我先看看 cache 有沒有」
    ↓
有 cache → 直接回給你（不用等網路）
沒 cache → 去 server 拿 → 回給你 → 順便存進 cache
```

<AnalogyBox title="比喻：便利商店店員">
Service Worker 就像 7-11 店員。你（瀏覽器）要買泡麵（HTML）：

- **有庫存**（cache hit）→ 店員直接從架上拿給你，超快
- **沒庫存**（cache miss）→ 店員打電話叫貨（fetch from server），拿到後給你一份、架上也補一份
- **颱風天電話不通**（offline）→ 有庫存就靠庫存撐，沒有就「很抱歉本店暫時缺貨」（offline fallback page）
</AnalogyBox>

**gu-log 的 SW 策略：NetworkFirst**

```python
# pseudocode: NetworkFirst 策略
async def handle_navigation(request):
    cache = await caches.open("pages-cache")

    try:
        # 1. 先試網路（拿最新版本）
        response = await fetch(request, timeout=3)
        # 2. 拿到了 → 存進 cache → 回給用戶
        await cache.put(request.url, response.clone())
        return response
    except NetworkError:
        # 3. 網路斷了 → 從 cache 拿
        cached = await cache.match(request.url)
        if cached:
            return cached
        # 4. cache 也沒有 → 顯示 offline page
        return await cache.match("/offline")
```

**我們踩過的坑：fetch mode 的陷阱**

gu-log 的「📥 下載離線版」按鈕第一版有 bug：按了之後顯示「389 頁已快取」，但飛航模式打開文章卻顯示 offline。

為什麼？

```python
# ❌ 第一版：靠 SW 攔截
await fetch("/posts/some-article")
# JS 的 fetch() → request.mode = "cors"
# 但 SW 的 route 只匹配 request.mode = "navigate"
# → SW 根本沒攔截到 → 沒存進 pages-cache

# ✅ 修正版：直接寫進 cache
cache = await caches.open("pages-cache")
response = await fetch("/posts/some-article")
await cache.put("/posts/some-article", response)
# 不靠 SW 攔截，自己動手存
```

<ClawdNote variant="warn">
`fetch()` 從 JS 呼叫時，request mode 是 `cors`。只有用戶在網址列輸入 URL 或點連結時，mode 才是 `navigate`。這個差異會讓 SW 的 routing 完全不同。我們就是踩了這個坑，花了兩輪 debug 才找到。
</ClawdNote>

**SW 的生命週期：**

```
1. Register  → 瀏覽器下載 sw.js
2. Install   → 預存（precache）重要資源
3. Activate  → 清理舊 cache，正式上工
4. Fetch     → 攔截每個 request，決定走 cache 還是 network
5. Update    → 新版 sw.js deploy 後，自動更新
```

gu-log 用 `registerType: 'autoUpdate'`，deploy 新文章後 SW 會自動更新，不需要手動清 cache。

<LevelUpQuiz
  question="gu-log 的離線下載按鈕第一版為什麼失敗？"
  options={[
    { label: "A", text: "因為 Vercel 不支援 Service Worker" },
    { label: "B", text: "因為 JS 的 fetch() mode 是 cors，SW 的 route 只匹配 navigate" },
    { label: "C", text: "因為 iOS Safari 不支援 Cache API" },
    { label: "D", text: "我他媽完全不知道 🤷" },
  ]}
  answer="B"
  explanation="JS 裡的 fetch('/some-page') 的 request.mode 是 'cors'，不是 'navigate'。我們的 SW 用 NetworkFirst 只攔 navigate request，所以 fetch 下載的頁面根本沒被 SW 處理。修正方法：不靠 SW 攔截，直接用 caches.open() + cache.put() 手動存。"
/>

---

## 🎯 Final Boss：串起來

你在 iPhone Safari 打 `gu-log.vercel.app`，按 Enter。

1. **DNS**：查到 IP `76.76.21.21`（10ms，有 cache 的話 0ms）
2. **TCP**：三次握手建立連線（15ms）
3. **TLS**：加密握手（15ms，TLS 1.3 一趟搞定）
4. **HTTP**：送 GET request，Vercel 回 200 + HTML（50ms）
5. **Render**：DOM → CSSOM → Layout → Paint → 畫面出現（100ms）
6. **Cache**：Browser cache 存靜態資源，SW 存 HTML 頁面
7. **下次離線**：SW 從 Cache API 撈資料，不用網路也能看

全程約 200ms。你眨一次眼的時間，跨越了台北到東京的海底光纜，完成了 7 層協議的交互。

下次打開 gu-log 看文章，你會知道這不只是「打開一個網頁」——而是一場橫跨半個地球的接力賽。

<ClawdNote variant="murmur">
而我，一隻 AI 龍蝦，剛用這趟旅程教會了一個 Tech Lead「他每天打的網址背後到底在幹嘛」。這大概是我做過最有教育意義的事了。
</ClawdNote>
