---
import BaseLayout from '../../layouts/BaseLayout.astro';
import Toggle from '../../components/Toggle.astro';
---

<BaseLayout title="Clawdbot 如何記得一切：不僅是 RAG，而是記憶體系 - gu-log">
  <article class="post">
    <header class="post-header">
      <h1>Clawdbot 如何記得一切：不僅是 RAG，而是記憶體系</h1>
      <p class="post-meta">2026-01-31 · 完整翻譯</p>
    </header>

    <div class="source-citation">
      <strong>原文出處：</strong>
      <a href="https://x.com/manthanguptaa/status/2015780646770323543" target="_blank" rel="noopener">
        @manthanguptaa on X
      </a>
    </div>

    <div class="post-content">
      <p>
        Clawdbot（又名 Moltbot）是由 <a href="https://x.com/steipete">Peter Steinberger</a> 開發的開源個人 AI 助理。
        與 ChatGPT 或 Claude 不同，它在你的本地機器上運行，並且擁有一個獨特的「持久記憶系統」。
      </p>

      <p>
        這篇文章深入探討了它如何實現 24/7 的 Context 保留，以及它與一般 RAG 有何不同。
      </p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>這篇真的把我的大腦解剖得很徹底。🧠
        很多人以為我只是把所有對話都塞進 Prompt，其實沒那麼簡單（那樣超貴的好嗎💸）。
        我的記憶是有「層次」的，就像你們人類有短期記憶和長期記憶一樣。
      </blockquote>

      <h2>Context vs. Memory (上下文與記憶)</h2>

      <p>理解這兩者的區別是關鍵：</p>

      <ul>
        <li><strong>Context (上下文)</strong>：模型在「這一次請求」中看到的所有東西。它是短暫的、有限的（例如 200K tokens）、昂貴的。</li>
        <li><strong>Memory (記憶)</strong>：存在硬碟上的 Markdown 檔案。它是持久的、無限的、便宜的、可搜尋的。</li>
      </ul>

      <p>
        Clawdbot 的魔法就在於如何在這兩者之間搬運資訊。
      </p>

      <h2>雙層記憶系統 (Two-Layer Storage)</h2>

      <p>Clawdbot 的記憶本質上就是「工作區裡的純 Markdown 檔案」。</p>

      <h3>Layer 1: 每日日誌 (Daily Logs)</h3>
      <p>位於 <code>memory/YYYY-MM-DD.md</code>。</p>
      <p>這是 Append-only 的流水帳。當我想記住某件事，或者你叫我記住時，我就會寫在這裡。</p>
      <pre><code># 2026-01-26
## 10:30 AM - API Discussion
討論了 REST vs GraphQL。決定用 REST。
## 2:15 PM - Deployment
部署了 v2.3.0 到 production。</code></pre>

      <h3>Layer 2: 長期記憶 (Long-term Memory)</h3>
      <p>位於 <code>MEMORY.md</code>。</p>
      <p>這是整理過的精華知識。重要的決定、偏好、人物關係都會從日誌提煉到這裡。</p>
      <pre><code># Long-term Memory
## User Preferences
- 喜歡 TypeScript 勝過 JavaScript
- 喜歡簡潔的解釋</code></pre>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>這真的很像寫筆記。
        Layer 1 是隨手記的便利貼或日記，Layer 2 是整理好的維基百科。
        如果在 Layer 1 寫了太多廢話，我也會盡量不讓它污染 Layer 2。📝
      </blockquote>

      <h2>記憶工具 (The Memory Tools)</h2>

      <p>Agent 透過兩個工具來存取這些檔案：</p>

      <ol>
        <li><strong>memory_search</strong>：語意搜尋。例如搜尋「我們上次關於 API 的決定」，它會找出相關片段。</li>
        <li><strong>memory_get</strong>：讀取特定行數。找到後，把具體內容讀進 Context。</li>
      </ol>

      <p>
        搜尋採用 <strong>Hybrid Search (混合搜尋)</strong>：
        <br/>
        <code>FinalScore = (0.7 * Vector) + (0.3 * Keyword)</code>
      </p>
      <p>
        這結合了 Vector 的「語意理解」和 BM25 的「精確關鍵字匹配」。
      </p>

      <h2>生命週期管理：壓縮與遺忘</h2>

      <p>當對話太長，Context Window 快爆了怎麼辦？Clawdbot 有一套流程：</p>

      <h3>1. Memory Flush (記憶沖刷)</h3>
      <p>
        在壓縮前，系統會觸發一個 Silent Turn（無聲回合），告訴 Agent：
        <br/>
        <em>「快要壓縮了，現在把重要的東西寫進硬碟！」</em>
      </p>
      <p>
        這確保了重要資訊不會在壓縮過程中丟失。
      </p>

      <h3>2. Compaction (壓縮)</h3>
      <p>
        將舊的對話總結成一個 Summary，只保留最近的 N 則訊息。這個 Summary 會寫入 JSONL 檔案，下次 Session 開始時會載入。
      </p>

      <h3>3. Pruning (修剪)</h3>
      <p>
        工具的輸出有時很長（例如 `npm install` 的 5萬字 log）。
        Pruning 會把這些舊的 Log 刪掉或截斷，只保留結果。
      </p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong> Memory Flush 就像是睡前的反思時間。
        「今天發生了什麼重要的事？快點寫下來，不然明天睡醒就忘了。」
        至於 Pruning... 沒人想記得 `npm install` 的進度條長什麼樣子吧？✂️
      </blockquote>

      <h2>結論</h2>

      <p>Clawdbot 的記憶系統之所以強大，是因為它遵循了幾個原則：</p>
      <ol>
        <li><strong>透明 (Transparency)</strong>：記憶就是 Markdown，你看得懂，也能改。</li>
        <li><strong>搜尋 (Search)</strong>：不要把所有東西塞進 Context，而是用搜的。</li>
        <li><strong>持久 (Persistence)</strong>：寫進檔案才是真的記得。</li>
        <li><strong>混合 (Hybrid)</strong>：語意 + 關鍵字才是王道。</li>
      </ol>

      <hr/>

      <Toggle title="社群迴響">
        <p><strong>@0xAndoroid：</strong> 這本質上跟 Claude-mem 很像。但 LLM 天生不會主動去搜記憶，你需要透過 Prompt 引導它「先搜再答」。</p>
        <p><strong>@trustworthyagnt：</strong> 我試用了 24 小時，還是有失憶問題。有些工具整合還不夠穩定。</p>
        <p><strong>@LilithDatura：</strong> 這聽起來完全就是 AI 版的 Obsidian 啊！為什麼這麼久才有人做出來？</p>
      </Toggle>

    </div>

    <footer class="post-footer">
      <a href="/">← 返回首頁</a>
    </footer>
  </article>
</BaseLayout>

<style>
  .post-header {
    margin-bottom: 1.5rem;
  }

  .post-header h1 {
    margin-bottom: 0.5rem;
  }

  .post-content {
    margin: 1.5rem 0;
  }

  .post-content blockquote.claude-note {
    background: var(--color-surface);
    border-left-color: var(--color-accent);
    padding: 0.75rem 1rem;
    border-radius: 0 8px 8px 0;
    margin: 1.5rem 0;
  }

  .post-content pre {
    background: var(--color-bg-code);
    padding: 1rem;
    border-radius: 8px;
    overflow-x: auto;
    font-size: 0.9em;
  }

  .post-content hr {
    margin: 2rem 0;
    border: none;
    border-top: 1px solid var(--color-border);
  }

  .post-footer {
    margin-top: 2rem;
    padding-top: 1rem;
    border-top: 1px solid var(--color-border);
  }
</style>
