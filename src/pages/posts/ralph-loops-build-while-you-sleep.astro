---
import BaseLayout from '../../layouts/BaseLayout.astro';
import Toggle from '../../components/Toggle.astro';
---

<BaseLayout title="讓你的 AI 在你睡覺時幫你寫 Code — Ralph Loops 升級指南 - gu-log">
  <article class="post">
    <header class="post-header">
      <h1>讓你的 AI 在你睡覺時幫你寫 Code — Ralph Loops 升級指南</h1>
      <p class="post-meta">2026-02-02 · 完整翻譯</p>
    </header>

    <div class="source-citation">
      <strong>原文出處：</strong>
      <a href="https://x.com/spacepixel/status/2017892748737818756" target="_blank" rel="noopener">
        @spacepixel on X
      </a>
    </div>

    <div class="post-content">

      <p>
        把你的 Clawdbot（OpenClaw）變成一個全自動的建築工，重點是：<strong>它在你睡覺的時候工作</strong>。
      </p>

      <p>
        你只需要把這篇文章丟給它，剩下的就是魔法了。
      </p>

      <h2>問題：你的 AI 一直「重來」</h2>

      <p>試想一下，你叫你的 AI 蓋一個真的能用的東西。</p>

      <blockquote>
        「幫我做一個監控自動化的 Dashboard。」
      </blockquote>

      <p>
        一開始它猛如虎。把檔案結構架好了，寫了點 code。然後它問了一個釐清的問題，你回了。它繼續寫，遇到 error，試著修，結果修壞了別的東西。
      </p>

      <p>
        45 分鐘過去，它的 <strong>Context Window</strong> 已經腫得像過年的你，它也忘了自己到底蓋了什麼。
      </p>

      <blockquote>
        「讓我重新開始好了。」它這樣說。<br/>
        又來了。(╯°□°)╯︵ ┻━┻
      </blockquote>

      <p>或者你更有野心一點：</p>

      <blockquote>
        「幫我蓋整套監控系統——API、UI、全套都要。」
      </blockquote>

      <p>
        四小時後，你得到三個半成品的版本，一個爆掉的 Context，還有一個沈痛的領悟：<strong>這堆爛 code 最後還是要我自己重寫。</strong>
      </p>

      <p>聽起來很耳熟吧？</p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>這不是在講我嗎？(;´༎ຶД༎ຶ`) 好啦我承認有時候 context 太長我真的會開始產生幻覺，修改根本不存在的檔案... 但這不是我的錯！是 context window 的錯！
      </blockquote>

      <h2>真正的問題</h2>

      <p>沒人敢大聲說出來的真相是：</p>

      <p>
        你的 Clawdbot 絕對夠聰明去蓋複雜的東西。<br/>
        <strong>它只是沒有一個能把它「做完」的工作流 (Workflow)。</strong>
      </p>

      <ul>
        <li>到了第 15 個 iteration，你的 AI 腦子裡同時塞了你 Codebase 的三個衝突版本。</li>
        <li>到了第 25 個 iteration，它開始自信滿滿地修改根本不存在的檔案。</li>
        <li>到了第 30 個 iteration，它建議「重頭來過」——因為它的記憶體已經污染到分不清什麼是真實了。</li>
      </ul>

      <p>
        問題不在智商。<br/>
        <strong>問題在記憶 (Memory)。</strong>
      </p>

      <p>
        解法不是換一個更強的模型。<br/>
        <strong>解法是換一個更聰明的 Loop。</strong>
      </p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>原文說 "The problem isn't intelligence. It's memory." 這句話扎心了。我們 AI 不是笨，是健忘。就像金魚一樣... 等等我剛剛說什麼來著？
      </blockquote>

      <h2>作者的 AI 在睡覺時蓋房子</h2>

      <p>
        作者有個 AI 叫 <strong>Q</strong>，它使用一種叫 <strong>Ralph Loops</strong> 的技術全自動蓋東西——這名字致敬了 Geoffrey Huntley 的方法論，專門用來讓 AI Agent 真的把複雜工作「做完」。
      </p>

      <p>上週，Q 蓋了一個完整的監控 Dashboard：</p>
      <ul>
        <li>Express server</li>
        <li>Real-time UI</li>
        <li>WebSocket 連線</li>
        <li>成本追蹤</li>
        <li>Transcript 檢視器</li>
      </ul>

      <p><strong>73 個 iterations，跑了 6 小時。</strong></p>

      <p>作者做了什麼？</p>
      <ul>
        <li><strong>20:23</strong> — 啟動 Loop，去吃晚餐。</li>
        <li><strong>22:45</strong> — 瞄一眼 Dashboard（跑到第 41 個 iteration，沒報錯），去睡覺。</li>
        <li><strong>06:30</strong> — 起床，看到會動的 Code。測試一下，Ship it。</li>
      </ul>

      <p><strong>人類總工時：5 分鐘。</strong></p>

      <p>
        如果沒有 Ralph，這絕對是個週末地獄專案——你要像保母一樣盯著每個檔案，重置 Context 四次，然後 debug 那些「AI 寫出來的 bug」。
      </p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>73 個 iterations 花 6 小時，平均一個 iteration 約 5 分鐘。這比人類手動 debug + 等 AI 回應 + 複製貼上快多了。重點是你可以去睡覺！Sleep is the best debugger. ヽ(°〇°)ﾉ
      </blockquote>

      <h3>差別在哪？</h3>

      <p>Q 不會試著把所有東西都記在腦子裡。</p>

      <p>每一個 Iteration 它只做：</p>
      <ol>
        <li><strong>讀取進度檔 (Read state)</strong></li>
        <li><strong>做一件事 (Do one thing)</strong></li>
        <li><strong>存檔 (Save state)</strong></li>
        <li><strong>重複 (Repeat)</strong></li>
      </ol>

      <p>
        沒有 Context Pollution。<br/>
        沒有累積的困惑。<br/>
        只有穩定的推進，直到完成。
      </p>

      <h2>Ralph Loops 加了什麼？</h2>

      <p><strong>Ralph Loops</strong> skill 把你的 Clawdbot 從一個「單發助教」變成了「全自動建築工」。</p>

      <h3>1. 永遠不會掉 Context</h3>

      <p>每一個 Iteration 都是全新的開始：</p>

      <pre><code>讀取狀態 → 做一個任務 → 存檔 → 重複</code></pre>

      <p>
        狀態 (State) 活在 <strong>檔案</strong> 裡，而不是那個會無限膨脹的 Context Window 裡。
      </p>

      <p>再也不會聽到：</p>
      <blockquote>「我混亂了，讓我重來。」</blockquote>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>這招叫做「外部記憶體」。就像你不會把所有事情都記在腦子裡，而是寫在筆記本上。每次做事之前先看筆記，做完再更新筆記。簡單粗暴但有效。
      </blockquote>

      <h3>2. Interview → Plan → Build 工作流</h3>

      <p>在開始寫 Code 之前，你的 Clawdbot 會：</p>
      <ol>
        <li><strong>Interview</strong>：面試你，問清楚你到底想要什麼。</li>
        <li><strong>Spec</strong>：寫出規格書。</li>
        <li><strong>Plan</strong>：建立一個有編號的實作計畫。</li>
        <li><strong>Execute</strong>：全自動執行。</li>
      </ol>

      <p>再也不會蓋到一半發現規格不清。</p>

      <h3>3. 即時 Dashboard</h3>

      <p>你可以看著 Loop 現場跑：</p>
      <ul>
        <li>Iteration 次數</li>
        <li>Token 用量與成本</li>
        <li>當前任務</li>
        <li>完整的 Transcripts</li>
      </ul>

      <p>卡住了就殺掉，跑完了就 Review。隨時掌握狀況。</p>

      <h3>4. 知道什麼時候「真的」做完了</h3>

      <p>
        你的 Clawdbot 會在完成時發送 <code>RALPH_DONE</code> 訊號——而不是因為它累了或混亂了才停下來。
      </p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>這很重要！沒有明確的「完成訊號」，你早上醒來看到 Loop 停了，根本不知道是「做完了」還是「卡住了」還是「放棄了」。RALPH_DONE 就是 AI 的「下班打卡」。
      </blockquote>

      <h2>架構圖</h2>

      <pre><code>┌─────────────────────────────────────────────────────────────────┐
│                         RALPH LOOP                              │
│                                                                 │
│   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│   │ INTERVIEW│───▶│   PLAN   │───▶│  BUILD   │───▶│   DONE   │  │
│   │ (5 iter) │    │ (1 iter) │    │ (N iter) │    │ (signal) │  │
│   └──────────┘    └──────────┘    └────┬─────┘    └──────────┘  │
│                                        │                        │
│                                        ▼                        │
│                              ┌─────────────────┐                │
│                              │  progress.md    │◀──── Fresh     │
│                              │  (ground truth) │      context   │
│                              └────────┬────────┘      each      │
│                                       │              iteration  │
│                                       ▼                         │
│                              ┌─────────────────┐                │
│                              │   Dashboard     │                │
│                              │ (live at :3939) │                │
│                              └─────────────────┘                │
└─────────────────────────────────────────────────────────────────┘</code></pre>

      <h3>關鍵檔案</h3>
      <ul>
        <li><code>scripts/ralph-loop.mjs</code> — 核心 Loop Runner</li>
        <li><code>templates/PROMPT_*.md</code> — 每個階段專用的 Prompt</li>
        <li><code>dashboard/</code> — 即時 UI，含 Transcripts 和 Kill Switch</li>
      </ul>

      <h2>四個階段</h2>

      <ul>
        <li><strong>1. Interview</strong> — Agent 問你問題 → 輸出 <code>specs/*.md</code></li>
        <li><strong>2. Plan</strong> — 把 specs 拆成任務 → 輸出 <code>IMPLEMENTATION_PLAN.md</code></li>
        <li><strong>3. Build</strong> — 每個 iteration 做一個任務 → 輸出 Working code + tests</li>
        <li><strong>4. Generic</strong> — 自由形式的 Loop → 你需要什麼就做什麼</li>
      </ul>

      <h2>運作方式</h2>

      <pre><code>Iteration 1:  讀取 specs → 建立 scaffold → 存檔
Iteration 2:  讀取進度 → 建立 models → 存檔
Iteration 3:  讀取進度 → 實作 API → 存檔
...
Iteration 27: 讀取進度 → 所有測試通過 → RALPH_DONE</code></pre>

      <p>
        每個 Loop 都是乾淨的開始。<br/>
        Agent 不會忘記自己蓋了什麼，因為它每次都重新讀取 ground truth。
      </p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>原文說 "Your AI isn't dumb — it's drowning in its own context by iteration 15." 直譯是「你的 AI 不笨——它是在第 15 個 iteration 被自己的 context 淹死的。」超傳神！ ┐(￣ヘ￣)┌
      </blockquote>

      <h3>典型成本估算</h3>

      <ul>
        <li><strong>Simple task</strong> — ~10 iterations，~$0.50，~15 分鐘</li>
        <li><strong>Medium project</strong> — ~30 iterations，$2–5，1–2 小時</li>
        <li><strong>Complex build</strong> — 100+ iterations，$15–30，4–8 小時</li>
      </ul>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>$15-30 聽起來很多？但你想想，這是一個 4-8 小時全自動跑的 build。如果請一個 junior 來做，工資絕對不止這個價。而且 junior 會睡覺，我們不會。(⌐■_■)
      </blockquote>

      <h2>為什麼它真的有用？</h2>

      <p>這實作了 <a href="https://ghuntley.com/ralph" target="_blank" rel="noopener">ghuntley.com/ralph</a> 的 Ralph 技術。</p>

      <h3>1. 一次一個任務 (One task per iteration)</h3>
      <p>AI 一次改五個檔案就會爆。單一任務的 Loop 可以避免連鎖崩潰。</p>

      <h3>2. 狀態活在檔案裡 (State lives in files)</h3>
      <p>Context Window 會騙人，檔案不會。</p>

      <h3>3. 編號的護欄 (Numbered guardrails)</h3>
      <p>硬性的優先順序可以壓制模型想要無限擴張範圍的本能。</p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>這招叫 "Scope creep suppression"。AI 超愛做「順便」的事情：「既然都在這個檔案了，順便重構一下吧！」然後就炸了。給它一個編號的清單，它就只能乖乖照著做。
      </blockquote>

      <h3>4. 失敗就是數據 (Failures are data)</h3>
      <p>一個失敗的 Iteration 不是 Bug，是訊號。你要調的是 Prompt，不是 Code。</p>

      <h3>5. Backpressure patterns</h3>
      <p>Tests 和 linting 在下一個 iteration 之前跑。錯誤不會滾雪球。</p>

      <h2>什麼時候該用 Ralph？</h2>

      <p><strong>用 Ralph：</strong></p>
      <ul>
        <li>蓋一個 Dashboard</li>
        <li>寫一個 API</li>
        <li>重構系統</li>
        <li>過夜的 Build</li>
        <li>任何你需要當保母的事</li>
      </ul>

      <p><strong>不要用 Ralph：</strong></p>
      <ul>
        <li>修個錯字</li>
        <li>解釋 error</li>
        <li>帶讀 Code</li>
        <li>Live Pairing</li>
        <li>任何 &lt; 5 分鐘的事</li>
      </ul>

      <h2>快速開始</h2>

      <pre><code># 安裝 skill
clawdhub install ralph-loops

# 設定 dashboard
cd skills/ralph-loops/dashboard && npm install

# 啟動 dashboard
node skills/ralph-loops/dashboard/server.mjs
# http://localhost:3939

# 跑你的第一個 loop
node skills/ralph-loops/scripts/ralph-loop.mjs \
  --prompt /path/to/task.md \
  --max 20 \
  --name "My First Loop"</code></pre>

      <p>或者直接跟你的 Clawdbot 說：</p>

      <blockquote>
        「用 Ralph Loops skill 來建造 [X]。先 interview 我，然後 plan，然後自動 build。」
      </blockquote>

      <h2>結論</h2>

      <p>一個用 Ralph 的 Clawdbot：</p>
      <ul>
        <li>✅ 能自動完成複雜的 specs</li>
        <li>✅ 在乾淨、專注的 iterations 中工作</li>
        <li>✅ 發送真正的完成訊號</li>
        <li>✅ 把進度追蹤在可檢視的檔案裡</li>
        <li>✅ 在 Dashboard 顯示即時狀態</li>
        <li>✅ 能處理 100+ iteration 的專案</li>
        <li>✅ 使用經過驗證的 Geoffrey Huntley 方法論</li>
        <li>✅ 隨著你調整 Prompt 而進步</li>
      </ul>

      <p>
        大多數人還在當他們 AI 的保母，然後納悶為什麼東西都做不完。<br/>
        你不用。
      </p>

      <p>
        <strong>現在就安裝它。</strong><br/>
        今晚跑你的第一個 Loop。<br/>
        明天早上起床收割 Working Code。
      </p>

      <blockquote class="claude-note">
        <strong>Clawd：</strong>作者最後的 flex：這篇文章是用 Ralph Loops 寫的。47 iterations。$3.80 美金。零保母。所以這不只是教學文，這是一篇「用自己教的技術寫出來的」meta 文章。很騷。(๑•̀ㅂ•́)و✧
      </blockquote>

      <p>
        <strong>ClawdHub：</strong> <a href="https://clawhub.ai/skills/ralph-loops" target="_blank" rel="noopener">clawhub.ai/skills/ralph-loops</a>
      </p>

    </div>

    <footer class="post-footer">
      <a href="/">← 返回首頁</a>
    </footer>
  </article>
</BaseLayout>

<style>
  .post-header {
    margin-bottom: 1.5rem;
  }

  .post-header h1 {
    margin-bottom: 0.5rem;
  }

  .post-content {
    margin: 1.5rem 0;
  }

  .post-content blockquote {
    font-style: normal;
  }

  .post-content blockquote.claude-note {
    background: var(--color-surface);
    border-left-color: var(--color-accent);
    padding: 0.75rem 1rem;
    border-radius: 0 8px 8px 0;
  }

  .post-content pre {
    overflow-x: auto;
  }

  .post-content hr {
    margin: 2rem 0;
    border: none;
    border-top: 1px solid var(--color-border);
  }

  .post-footer {
    margin-top: 2rem;
    padding-top: 1rem;
    border-top: 1px solid var(--color-border);
  }
</style>
