---
import BaseLayout from '../../layouts/BaseLayout.astro';
import Toggle from '../../components/Toggle.astro';
---

<BaseLayout title="Redis 不只是 Cache：別開著法拉利去買菜 - gu-log">
  <article class="post">
    <header class="post-header">
      <h1>Redis 不只是 Cache：別開著法拉利去買菜</h1>
      <p class="post-meta">2026-01-30 · 完整翻譯</p>
    </header>

    <div class="source-citation">
      <strong>原文出處：</strong>
      <a href="https://x.com/KartikeyStack/status/2016769146781077767" target="_blank" rel="noopener">
        @KartikeyStack on X
      </a>
    </div>

    <div class="post-content">

      <p>
        <strong>"大部分開發者認識 Redis 是作為 Cache。"</strong>
      </p>

      <p>
        你把它丟在資料庫前面，加個 <span class="term">TTL</span>，看著回應時間從 500ms 掉到 50ms，然後就繼續做別的事了。Redis 安靜地工作，系統變快了，大家都很開心。
      </p>

      <Toggle title="名詞解釋：TTL (Time To Live)">
        <p><strong>TTL (存活時間)</strong>：資料在快取中保留多久會自動過期。例如設 TTL = 1小時，那這筆資料 1 小時後就會自動消失，下次讀取時就要重新從資料庫抓。</p>
      </Toggle>

      <p>
        但把 Redis 只當 Cache 用，<strong>就像買了一台法拉利卻只開去買菜</strong>。它當然很快，但你錯過了重點。
      </p>

      <p>
        Redis 不是一個剛好很快的 Cache。它是一個<strong>資料結構伺服器 (Data Structure Server)</strong>，只是剛好很適合當 Cache。這個區別改變了一切。
      </p>

      <h2>Redis 到底是什麼？</h2>

      <p>Redis = <strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver。</p>

      <p>大部分 Cache 把資料當成一坨看不懂的字串（JSON String）。但 Redis 懂<strong>資料結構</strong>：</p>
      <ul>
        <li>Strings (字串)</li>
        <li>Hashes (雜湊/字典)</li>
        <li>Lists (列表)</li>
        <li>Sets (集合)</li>
        <li>Sorted Sets (有序集合)</li>
        <li>Streams (串流)</li>
        <li>Geospatial (地理位置)</li>
        <li>HyperLogLogs (基數估算)</li>
      </ul>

      <p>Redis 不只是存這些結構，它知道如何<strong>安全且原子地 (Atomically)</strong> 修改它們。</p>

      <Toggle title="名詞解釋：Atomic (原子性)">
        <p><strong>Atomic (原子性)</strong>：操作要嘛全部成功，要嘛全部失敗，不會有「做一半」的狀態。而且在操作過程中，別人不能插隊修改資料。這保證了資料的一致性。</p>
      </Toggle>

      <h2>思維轉變：Cache Thinking vs Redis Thinking</h2>

      <h3>❌ 傳統 Cache 做法 (Read-Modify-Write)</h3>

      <pre><code>// 1. 讀出來
const userData = await redis.get("user:1");
const user = JSON.parse(userData);

// 2. 修改 (在 App 層)
user.followers += 1;

// 3. 寫回去
await redis.set("user:1", JSON.stringify(user));</code></pre>

      <p>這會有 <span class="term">Race Condition</span>。如果兩個人同時讀取，同時加一，再寫回去，就會少算一次。</p>

      <Toggle title="名詞解釋：Race Condition (競爭條件)">
        <p><strong>Race Condition</strong>：當多個程序同時搶著讀寫同一筆資料時，因為執行順序不確定，導致結果錯誤的情況。像是兩個人同時領錢，餘額卻只扣一次。</p>
      </Toggle>

      <h3>✅ Redis Native 做法</h3>

      <pre><code>// 讓 Redis 處理狀態轉變
// 原子性地加 1，絕對不會算錯
await redis.hIncrBy("user:1", "followers", 1);</code></pre>

      <p>
        架構變得更乾淨。沒有 Read-Modify-Write 循環，沒有 Race Condition，不需要 Application-level locking。
      </p>

      <h2>為什麼 Redis 真的那麼快？</h2>

      <ol>
        <li><strong>Memory-first design</strong>：它不只是用 RAM，它針對記憶體存取模式最佳化了資料結構。</li>
        <li><strong>Simple operations</strong>：沒有複雜的 SQL JOIN，沒有查詢優化器。大多是 O(1) 或 O(log n)。</li>
        <li><strong>Single-threaded execution model</strong>：這聽起來是缺點，其實是優點。因為單執行緒，所以沒有 <span class="term">Lock Contention</span>。</li>
      </ol>

      <Toggle title="名詞解釋：Lock Contention (鎖競爭)">
        <p><strong>Lock Contention</strong>：在多執行緒環境下，大家為了搶同一把「鎖」（為了修改資料）而排隊等待。這會浪費大量時間。Redis 因為是單執行緒，大家乖乖排隊，反而省去了「搶鎖」的開銷。</p>
      </Toggle>

      <p>
        PostgreSQL 查詢: ~50ms<br/>
        Redis Cache: ~5ms<br/>
        <strong>Native Redis Operation: ~0.5ms</strong>
      </p>

      <h2>Redis 作為 State Manager (狀態管理器)</h2>

      <h3>1. Real-time Counters (即時計數)</h3>
      <p>
        不管是追蹤 Page Views 還是訪客數，Redis 的 <code>INCR</code> 只要微秒級。而在 Postgres 裡你需要 Lock row → Read → Write → Unlock → Write to <span class="term">WAL</span>。
      </p>

      <Toggle title="名詞解釋：WAL (Write Ahead Log)">
        <p><strong>WAL (預寫日誌)</strong>：資料庫為了保證資料不丟失，在真正修改資料檔之前，會先把操作記錄寫進 Log 檔。這是資料庫持久性的關鍵，但也增加了寫入的開銷。</p>
      </Toggle>

      <Toggle title="名詞解釋：HyperLogLog">
        <p><strong>HyperLogLog</strong>：一種神奇的演算法，可以用極小的記憶體（比如 12KB）來估算「有幾個不重複的元素」（例如 UV - Unique Visitors），誤差很小（~0.8%）。用來算幾億人的 UV 超級省空間。</p>
      </Toggle>

      <h3>2. Distributed Rate Limiting (分散式限流)</h3>
      <p>
        利用 <strong>Sorted Sets</strong> 做 <span class="term">Sliding Window</span> 限流。所有伺服器共享 Redis 裡的狀態，沒人能偷跑。
      </p>

      <Toggle title="名詞解釋：Sliding Window (滑動視窗)">
        <p><strong>Sliding Window</strong>：一種限流演算法。想像一個隨著時間移動的視窗（例如過去 1 分鐘）。我們只計算落在這個視窗內的請求數。比固定時間切片（每分鐘重置）更精準。</p>
      </Toggle>

      <h3>3. Session Storage</h3>
      <p>
        別再無腦用 <span class="term">JWT</span> 了。有時候你需要能夠「立即踢人下線」的 Session。Redis 有 TTL，可以自動過期，也可以手動刪除來登出用戶。
      </p>

      <Toggle title="名詞解釋：JWT (JSON Web Token)">
        <p><strong>JWT</strong>：一種無狀態的 Token。優點是伺服器不用存狀態，缺點是一旦發出去，在過期前都很難撤銷（除非做黑名單，那又變回有狀態了）。</p>
      </Toggle>

      <h3>4. Leaderboards (排行榜)</h3>
      <p>
        <strong>Sorted Sets</strong> 是排行榜神器。更新分數 O(log n)，抓取前 10 名 O(log n)。要在 SQL 裡做高效的即時排行榜非常痛苦，Redis 卻是內建功能。
      </p>

      <h3>5. Distributed Locking (分散式鎖)</h3>
      <p>
        當你需要跨多台伺服器保證「同一時間只有一個人能做這件事」（例如產生發票）時，用 Redis 實作 <span class="term">Redlock</span>。
      </p>

      <Toggle title="名詞解釋：Redlock">
        <p><strong>Redlock</strong>：Redis 官方提出的分散式鎖演算法。利用 Redis 的原子操作 (SETNX) 來確保鎖的安全性，並處理了節點故障等邊緣情況。</p>
      </Toggle>

      <h3>6. Pub/Sub (發布/訂閱)</h3>
      <p>
        即時聊天、通知系統。它是 Fire-and-forget（射後不理）。如果沒人聽，訊息就消失。
      </p>

      <Toggle title="名詞解釋：Pub/Sub & Fan-out">
        <p><strong>Pub/Sub</strong>：一種訊息模式。發布者 (Publisher) 把訊息丟到頻道，訂閱者 (Subscriber) 收聽頻道。發布者不用知道誰在聽。</p>
        <p><strong>Fan-out (扇出)</strong>：把一條訊息同時廣播給大量的訂閱者。例如 IG 名人發文，瞬間推播給百萬粉絲。</p>
      </Toggle>

      <h3>7. Streams (串流)</h3>
      <p>
        如果你需要持久化的訊息佇列（像 <span class="term">Kafka</span>），Redis Streams 是輕量級的替代方案。它支援 Consumer Groups，保證訊息被處理。
      </p>

      <Toggle title="名詞解釋：Kafka">
        <p><strong>Kafka</strong>：一個超大型、高吞吐量的分散式串流平台。通常用於大數據處理。Redis Streams 是它的輕量版，適合規模沒那麼大但需要類似功能的場景。</p>
      </Toggle>

      <h2>持久性 (Persistence)：Redis 重開機資料會不見？</h2>

      <p>迷思。Redis 其實有兩種持久化方式：</p>
      <ul>
        <li><strong>RDB (Snapshots)</strong>：定期快照。快，但可能掉幾分鐘資料。</li>
        <li><strong>AOF (Append-Only File)</strong>：記錄每一個寫入操作。資料更安全，但檔案較大。</li>
      </ul>

      <h2>Pipelines (管線化)</h2>

      <p>
        網路延遲是殺手。不要一個一個發指令。用 <span class="term">Pipeline</span> 把 1000 個指令打包一次發送，從 5 秒變 50ms。
      </p>

      <Toggle title="名詞解釋：Pipeline">
        <p><strong>Pipeline</strong>：就像去超市買東西，你不會買一樣結帳一次。你會把所有東西放到籃子裡，一次結帳。Pipeline 讓你可以一次發送多個 Redis 指令，減少網路來回的時間。</p>
      </Toggle>

      <h2>何時「不」該用 Redis？</h2>

      <ul>
        <li><strong>複雜關聯查詢</strong>：需要 JOIN？用 SQL。</li>
        <li><strong>資料大於記憶體</strong>：Redis 是 In-Memory 的。你有 100GB 資料但只有 16GB RAM？別用。</li>
        <li><strong>絕對的資料安全性</strong>：銀行交易紀錄？用專門的資料庫。</li>
        <li><strong>全文搜尋</strong>：雖然有 RediSearch，但 Elasticsearch 還是強項。</li>
      </ul>

      <h2>結論：架構模式</h2>

      <p>
        Redis 是<strong>共享的、快速的、記憶體內的狀態，並附帶原子操作</strong>。
      </p>

      <ul>
        <li><strong>Derived state</strong> (Cache, 統計) → Redis</li>
        <li><strong>Shared state</strong> (Session, Lock) → Redis</li>
        <li><strong>Ordered state</strong> (排行榜, Queue) → Redis</li>
        <li><strong>Location-based state</strong> (地理位置) → Redis</li>
        <li><strong>Primary business data</strong> (用戶, 訂單) → PostgreSQL/MySQL</li>
      </ul>

      <p>
        試著用 Redis 的 Sorted Sets 或 Pub/Sub 做點東西吧。當你停止把 Redis 只當成 Cache，你會發現新世界。
      </p>

    </div>

    <footer class="post-footer">
      <a href="/">← 返回首頁</a>
    </footer>
  </article>
</BaseLayout>

<style>
  .post-header {
    margin-bottom: 1.5rem;
  }

  .post-header h1 {
    margin-bottom: 0.5rem;
  }

  .post-content {
    margin: 1.5rem 0;
  }

  .post-content .term {
    font-weight: 500;
    color: var(--color-accent);
    background: rgba(var(--color-accent-rgb), 0.1);
    padding: 0 4px;
    border-radius: 4px;
  }

  .post-content blockquote {
    font-style: normal;
  }

  .post-content pre {
    overflow-x: auto;
  }

  .post-footer {
    margin-top: 2rem;
    padding-top: 1rem;
    border-top: 1px solid var(--color-border);
  }
</style>
