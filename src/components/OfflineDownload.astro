---
// Offline Download Button â€” caches all article pages for offline reading
interface Props {
  lang?: 'zh-tw' | 'en';
}
const { lang = 'zh-tw' } = Astro.props;
const label = lang === 'zh-tw' ? 'ğŸ“¥ ä¸‹è¼‰é›¢ç·šç‰ˆ' : 'ğŸ“¥ Download Offline';
const labelCaching = lang === 'zh-tw' ? 'å¿«å–ä¸­...' : 'Caching...';
const labelDone = lang === 'zh-tw' ? 'âœ… é›¢ç·šç‰ˆå·²å°±ç·’' : 'âœ… Ready for Offline';
const labelError = lang === 'zh-tw' ? 'âŒ å¿«å–å¤±æ•—' : 'âŒ Cache Failed';
---

<div class="offline-download-wrapper">
  <button
    class="offline-download-btn"
    id="offline-download-btn"
    data-label={label}
    data-label-caching={labelCaching}
    data-label-done={labelDone}
    data-label-error={labelError}
  >
    {label}
  </button>
  <div class="offline-progress" id="offline-progress">
    <div class="offline-progress-bar" id="offline-progress-bar"></div>
  </div>
  <p class="offline-status" id="offline-status"></p>
</div>

<script is:inline>
(function() {
  var btn = document.getElementById('offline-download-btn');
  var progress = document.getElementById('offline-progress');
  var progressBar = document.getElementById('offline-progress-bar');
  var status = document.getElementById('offline-status');
  if (!btn || !('serviceWorker' in navigator)) {
    if (btn) btn.style.display = 'none';
    return;
  }
  var isZh = btn.dataset.label.includes('é›¢ç·š');

  // Check if already cached
  async function checkCacheStatus() {
    try {
      var cache = await caches.open('pages-cache');
      var keys = await cache.keys();
      if (keys.length > 20) {
        btn.textContent = btn.dataset.labelDone;
        btn.classList.add('done');
        status.textContent = keys.length + (isZh ? ' é å·²å¿«å–' : ' pages cached');
      }
    } catch(_e) { /* ignore */ }
  }
  checkCacheStatus();

  // Fetch with retry + delay to avoid Vercel rate limiting
  function sleep(ms) { return new Promise(function(r) { setTimeout(r, ms); }); }

  async function fetchWithRetry(url, cache, retries) {
    for (var attempt = 0; attempt <= retries; attempt++) {
      try {
        var resp = await fetch(url);
        if (resp.ok) {
          await cache.put(url, resp);
          return true;
        }
        // 429 = rate limited â€” back off before retry
        if (resp.status === 429 && attempt < retries) {
          await sleep(1000 * (attempt + 1));
          continue;
        }
        return false;
      } catch(_e) {
        if (attempt < retries) {
          await sleep(500 * (attempt + 1));
          continue;
        }
        return false;
      }
    }
    return false;
  }

  btn.addEventListener('click', async function() {
    if (btn.classList.contains('done') || btn.classList.contains('caching')) return;
    btn.classList.add('caching');
    btn.textContent = btn.dataset.labelCaching;
    progress.style.display = 'block';

    try {
      // Fetch the search index to get all article URLs
      var res = await fetch('/search-index.json');
      var articles = await res.json();
      var urls = articles.map(function(a) { return a.url; });

      // Also add listing pages
      var allUrls = ['/', '/en/', '/clawd-picks/', '/en/clawd-picks/',
                     '/shroomdog-picks/', '/level-up/', '/about/', '/en/about/'];
      for (var i = 0; i < urls.length; i++) { allUrls.push(urls[i]); }

      // Skip URLs already in cache
      var cache = await caches.open('pages-cache');
      var existing = await cache.keys();
      var cachedSet = {};
      for (var k = 0; k < existing.length; k++) {
        var u = new URL(existing[k].url);
        cachedSet[u.pathname] = true;
      }
      var toFetch = [];
      for (var j = 0; j < allUrls.length; j++) {
        if (!cachedSet[allUrls[j]]) toFetch.push(allUrls[j]);
      }

      var total = allUrls.length;
      var alreadyCached = total - toFetch.length;
      var done = alreadyCached;
      var failed = 0;
      var concurrency = 3;  // gentler on Vercel
      var delayMs = 80;     // 80ms between fetches per worker
      var queue = toFetch.slice();

      function updateUI() {
        var pct = Math.round((done / total) * 100);
        progressBar.style.width = pct + '%';
        var msg = done + '/' + total;
        if (failed > 0) msg += ' (' + failed + ' failed)';
        status.textContent = msg;
      }
      updateUI();

      async function worker() {
        while (queue.length > 0) {
          var url = queue.shift();
          if (!url) break;
          var ok = await fetchWithRetry(url, cache, 2);
          if (!ok) failed++;
          done++;
          updateUI();
          // Small delay to avoid hammering Vercel edge
          if (queue.length > 0) await sleep(delayMs);
        }
      }

      var workers = [];
      for (var w = 0; w < concurrency; w++) { workers.push(worker()); }
      await Promise.all(workers);

      // If too many failures, offer retry for just the failed ones
      if (failed > 10) {
        btn.textContent = isZh ? 'ğŸ”„ é‡è©¦å¤±æ•—é é¢' : 'ğŸ”„ Retry Failed';
        btn.classList.remove('caching');
        status.textContent = (done - failed) + '/' + total + (isZh ? ' æˆåŠŸï¼Œé»æ“Šé‡è©¦' : ' ok, tap to retry');
        // Re-enable for retry â€” next click will re-run and skip already cached
        return;
      }

      btn.textContent = btn.dataset.labelDone;
      btn.classList.remove('caching');
      btn.classList.add('done');
      status.textContent = (total - failed) + (isZh ? ' é å·²å¿«å– âœˆï¸' : ' pages cached âœˆï¸');
    } catch(err) {
      btn.textContent = btn.dataset.labelError;
      btn.classList.remove('caching');
      status.textContent = err.message;
    }
  });
})();
</script>

<style>
  .offline-download-wrapper {
    text-align: center;
    margin: 1.5rem 0 0.5rem;
  }

  .offline-download-btn {
    display: inline-block;
    padding: 0.6rem 1.2rem;
    border: 1.5px solid var(--color-border, #444);
    border-radius: 8px;
    background: var(--color-surface, #1e1e2e);
    color: var(--color-text, #ccc);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .offline-download-btn:hover:not(.done):not(.caching) {
    border-color: var(--color-accent, #e67e22);
    color: var(--color-accent, #e67e22);
  }

  .offline-download-btn.caching {
    opacity: 0.7;
    cursor: wait;
  }

  .offline-download-btn.done {
    border-color: #27ae60;
    color: #27ae60;
    cursor: default;
  }

  .offline-progress {
    display: none;
    margin: 0.75rem auto;
    max-width: 300px;
    height: 4px;
    background: var(--color-border, #333);
    border-radius: 2px;
    overflow: hidden;
  }

  .offline-progress-bar {
    width: 0%;
    height: 100%;
    background: var(--color-accent, #e67e22);
    transition: width 0.15s ease;
    border-radius: 2px;
  }

  .offline-status {
    font-size: 0.8rem;
    color: var(--color-text-muted, #888);
    margin: 0.25rem 0 0;
  }
</style>
