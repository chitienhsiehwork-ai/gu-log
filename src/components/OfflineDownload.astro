---
// Offline Download Button â€” caches all article pages for offline reading
interface Props {
  lang?: 'zh-tw' | 'en';
}
const { lang = 'zh-tw' } = Astro.props;
const label = lang === 'zh-tw' ? 'ğŸ“¥ ä¸‹è¼‰é›¢ç·šç‰ˆ' : 'ğŸ“¥ Download Offline';
const labelCaching = lang === 'zh-tw' ? 'å¿«å–ä¸­...' : 'Caching...';
const labelDone = lang === 'zh-tw' ? 'âœ… é›¢ç·šç‰ˆå·²å°±ç·’' : 'âœ… Ready for Offline';
const labelError = lang === 'zh-tw' ? 'âŒ å¿«å–å¤±æ•—' : 'âŒ Cache Failed';
---

<div class="offline-download-wrapper">
  <button
    class="offline-download-btn"
    id="offline-download-btn"
    data-label={label}
    data-label-caching={labelCaching}
    data-label-done={labelDone}
    data-label-error={labelError}
  >
    {label}
  </button>
  <div class="offline-progress" id="offline-progress">
    <div class="offline-progress-bar" id="offline-progress-bar"></div>
  </div>
  <p class="offline-status" id="offline-status"></p>
</div>

<script is:inline>
(function() {
  var btn = document.getElementById('offline-download-btn');
  var progress = document.getElementById('offline-progress');
  var progressBar = document.getElementById('offline-progress-bar');
  var status = document.getElementById('offline-status');
  if (!btn || !('serviceWorker' in navigator)) {
    if (btn) btn.style.display = 'none';
    return;
  }
  var isZh = btn.dataset.label.includes('é›¢ç·š');

  // Check if a FULL download was previously completed
  async function checkCacheStatus() {
    try {
      var completed = localStorage.getItem('offline-download-done');
      if (!completed) return;
      var cache = await caches.open('pages-cache');
      var keys = await cache.keys();
      // Only show done if we previously completed AND cache still has substantial content
      var minPages = Math.floor(parseInt(completed, 10) * 0.8) || 100;
      if (keys.length >= minPages) {
        btn.textContent = btn.dataset.labelDone;
        btn.classList.add('done');
        status.textContent = keys.length + (isZh ? ' é å·²å¿«å–' : ' pages cached');
      } else {
        // Cache was partially evicted â€” clear flag, let user re-download
        localStorage.removeItem('offline-download-done');
      }
    } catch(_e) { /* ignore */ }
  }
  checkCacheStatus();

  // Fetch with retry + delay to avoid Vercel rate limiting
  function sleep(ms) { return new Promise(function(r) { setTimeout(r, ms); }); }

  async function fetchWithRetry(url, cache, retries) {
    for (var attempt = 0; attempt <= retries; attempt++) {
      try {
        var resp = await fetch(url);
        if (resp.ok) {
          await cache.put(url, resp);
          return true;
        }
        // 429 = rate limited â€” back off before retry
        if (resp.status === 429 && attempt < retries) {
          await sleep(1000 * (attempt + 1));
          continue;
        }
        return false;
      } catch(_e) {
        if (attempt < retries) {
          await sleep(500 * (attempt + 1));
          continue;
        }
        return false;
      }
    }
    return false;
  }

  btn.addEventListener('click', async function() {
    if (btn.classList.contains('done') || btn.classList.contains('caching')) return;
    btn.classList.add('caching');
    btn.textContent = btn.dataset.labelCaching;
    progress.style.display = 'block';

    try {
      // Pre-cache CSS/JS assets into assets-cache (ensures styles work offline)
      var assetsCache = await caches.open('assets-cache');
      var cssJsLinks = Array.from(document.querySelectorAll('link[rel="stylesheet"][href*="/_astro/"], script[src*="/_astro/"]'));
      for (var ci = 0; ci < cssJsLinks.length; ci++) {
        var assetUrl = cssJsLinks[ci].href || cssJsLinks[ci].src;
        if (assetUrl) {
          try {
            var assetResp = await fetch(assetUrl);
            if (assetResp.ok) await assetsCache.put(assetUrl, assetResp);
          } catch(_ae) { /* non-fatal */ }
        }
      }

      // Fetch the search index to get all article slugs â†’ build URLs
      var res = await fetch('/search-index.json');
      var articles = await res.json();

      // Listing + utility pages
      var allUrls = ['/', '/en/', '/clawd-picks/', '/en/clawd-picks/',
                     '/shroomdog-picks/', '/en/shroomdog-picks/',
                     '/shroomdog-originals/', '/en/shroomdog-originals/',
                     '/level-up/', '/about/', '/en/about/', '/glossary/'];

      // Article pages: build URL from slug + lang
      for (var i = 0; i < articles.length; i++) {
        var a = articles[i];
        if (a.lang === 'en') {
          allUrls.push('/en/posts/' + a.slug + '/');
        } else {
          allUrls.push('/posts/' + a.slug + '/');
        }
      }

      // Skip URLs already in cache
      var cache = await caches.open('pages-cache');
      var existing = await cache.keys();
      var cachedSet = {};
      for (var k = 0; k < existing.length; k++) {
        var u = new URL(existing[k].url);
        cachedSet[u.pathname] = true;
      }
      var toFetch = [];
      for (var j = 0; j < allUrls.length; j++) {
        if (!cachedSet[allUrls[j]]) toFetch.push(allUrls[j]);
      }

      var total = allUrls.length;
      var alreadyCached = total - toFetch.length;
      var done = alreadyCached;
      var failed = 0;
      var concurrency = 3;  // gentler on Vercel
      var delayMs = 80;     // 80ms between fetches per worker
      var queue = toFetch.slice();

      function updateUI() {
        var pct = Math.round((done / total) * 100);
        progressBar.style.width = pct + '%';
        var msg = done + '/' + total;
        if (failed > 0) msg += ' (' + failed + ' failed)';
        status.textContent = msg;
      }
      updateUI();

      // All pages already cached â€” skip straight to done
      if (toFetch.length === 0) {
        progressBar.style.width = '100%';
        btn.textContent = btn.dataset.labelDone;
        btn.classList.remove('caching');
        btn.classList.add('done');
        localStorage.setItem('offline-download-done', String(total));
        status.textContent = total + (isZh ? ' é å·²å¿«å– âœˆï¸' : ' pages cached âœˆï¸');
        return;
      }

      async function worker() {
        while (queue.length > 0) {
          var url = queue.shift();
          if (!url) break;
          var ok = await fetchWithRetry(url, cache, 2);
          if (!ok) failed++;
          done++;
          updateUI();
          // Small delay to avoid hammering Vercel edge
          if (queue.length > 0) await sleep(delayMs);
        }
      }

      var workers = [];
      for (var w = 0; w < concurrency; w++) { workers.push(worker()); }
      await Promise.all(workers);

      // Force progress bar to final state
      progressBar.style.width = '100%';

      // If too many failures, offer retry for just the failed ones
      if (failed > 10) {
        progressBar.style.width = Math.round(((done - failed) / total) * 100) + '%';
        btn.textContent = isZh ? 'ğŸ”„ é‡è©¦å¤±æ•—é é¢' : 'ğŸ”„ Retry Failed';
        btn.classList.remove('caching');
        status.textContent = (done - failed) + '/' + total + (isZh ? ' æˆåŠŸï¼Œé»æ“Šé‡è©¦' : ' ok, tap to retry');
        // Re-enable for retry â€” next click will re-run and skip already cached
        return;
      }

      btn.textContent = btn.dataset.labelDone;
      btn.classList.remove('caching');
      btn.classList.add('done');
      localStorage.setItem('offline-download-done', String(total - failed));
      status.textContent = (total - failed) + (isZh ? ' é å·²å¿«å– âœˆï¸' : ' pages cached âœˆï¸');
    } catch(err) {
      btn.textContent = btn.dataset.labelError;
      btn.classList.remove('caching');
      status.textContent = err.message;
    }
  });
})();
</script>

<style>
  .offline-download-wrapper {
    text-align: center;
    margin: 1.5rem 0 0.5rem;
  }

  .offline-download-btn {
    display: inline-block;
    padding: 0.6rem 1.2rem;
    border: 1.5px solid var(--color-border, #444);
    border-radius: 8px;
    background: var(--color-surface, #1e1e2e);
    color: var(--color-text, #ccc);
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .offline-download-btn:hover:not(.done):not(.caching) {
    border-color: var(--color-accent, #e67e22);
    color: var(--color-accent, #e67e22);
  }

  .offline-download-btn.caching {
    opacity: 0.7;
    cursor: wait;
  }

  .offline-download-btn.done {
    border-color: #27ae60;
    color: #27ae60;
    cursor: default;
  }

  .offline-progress {
    display: none;
    margin: 0.75rem auto;
    max-width: 300px;
    height: 4px;
    background: var(--color-border, #333);
    border-radius: 2px;
    overflow: hidden;
  }

  .offline-progress-bar {
    width: 0%;
    height: 100%;
    background: var(--color-accent, #e67e22);
    transition: width 0.15s ease;
    border-radius: 2px;
  }

  .offline-status {
    font-size: 0.8rem;
    color: var(--color-text-muted, #888);
    margin: 0.25rem 0 0;
  }
</style>
